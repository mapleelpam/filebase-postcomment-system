// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "TokenService.h"
#include "token_dispatch.h"

#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <boost/thread.hpp>
#include <time.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace tw::maple::generated;
using namespace tw::test;

TokenManager *g_token_manager;

struct cleanExpireContextThread
{
    void operator()()
    {
        int sleep_time = 3;

        while(1) {
            printf("clean context thread sleep_time = %d\n", sleep_time);
            boost::this_thread::sleep(boost::posix_time::seconds(sleep_time));
            int32_t next_sleep = g_token_manager->checkExpireContext();

            sleep_time = (next_sleep > 0) ? next_sleep : 3;
        }
    };
};

class TokenServiceHandler : virtual public TokenServiceIf
{
public:
    TokenServiceHandler() {
        // Your initialization goes here
    }

    void getToken(std::string& _return, const std::string& userId, const int32_t default_expire_time)
    {
        std::string token = g_token_manager->genToken();
        std::string key = userId + "_" + token;
        TokenContextPtr context(new TokenContext(userId, token, default_expire_time));

        g_token_manager->insertToken(context);
        _return = key;
//        printf("expireTime: %d, token: %s, userId: %s\n", default_expire_time, token.c_str(), userId.c_str());
    }

    void removeToken(const std::string& token)
    {
        printf("removeToken\n");
        ErrorCode rc = g_token_manager->removeToken(token);

        if(rc == CANT_FOUND_TOKEN) {
            NotFoundException nfe;

            nfe.why = "Token Not Found";
            throw nfe;
        }
    }

    void checkToken(const std::string& token)
    {
        printf("checkToken\n");
        ErrorCode rc = g_token_manager->isTokenOK(token);

        if(rc == CANT_FOUND_TOKEN) {
            NotFoundException nfe;

            nfe.why = "Token Not Found";
            throw nfe;
        }
    }

    void getURL(std::string& _return, const std::string& token,
            const std::string& itemKey, const int32_t expireTime)
    {
        printf("getURL\n");
        checkToken(token);

        _return  = g_token_manager->genURL(token, itemKey, expireTime);
    }

    void checkURL(const std::string &url)
    {
        printf("checkURL\n");
        if(g_token_manager->checkURL(url) != SUCCESS) {
            NotFoundException nfe;

            nfe.why = "URL Not Exist";
            throw nfe;
        }
    }
};

int main(int argc, char **argv)
{
    int port = 9090;
    shared_ptr<TokenServiceHandler> handler(new TokenServiceHandler());
    shared_ptr<TProcessor> processor(new TokenServiceProcessor(handler));
    shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

    g_token_manager = new (std::nothrow) TokenManager();

    // create clean expire context thread
    cleanExpireContextThread clean_context;
    boost::thread clean_thread(clean_context);
    clean_thread.detach();

    server.serve();
    return 0;
}

